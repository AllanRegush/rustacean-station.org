#!/usr/bin/python3

"""
A quick script to extract the text from a transcript generated by AWS Transcribe.
Download the transcript in JSON format and feed it to this script to get the text.
"""

import argparse
import hashlib
import json
import sys
import time
from urllib.request import urlopen
try:
    import boto3
except ModuleNotFoundError:
    # we can do some functions without boto3.
    pass

# boto3 will automatically detect these environment variables:
# AWS_ACCESS_KEY_ID
# AWS_SECRET_ACCESS_KEY

AWS_REGION = 'us-west-2'

class TranscribeError(Exception):
    pass

class AwsTranscribe:
    def __init__(self):
        self.scribe = boto3.client('transcribe', region_name=AWS_REGION)
        #self.s3 = boto3.client('s3', region_name=AWS_REGION)

    def list_vocab(self):
        response = self.scribe.list_vocabularies()
        result = [v['VocabularyName'] for v in response['Vocabularies']]
        print(result)

    def fetch_transcript(self, job_name):
        response = self.scribe.get_transcription_job(
            TranscriptionJobName=job_name
        )
        uri = response['TranscriptionJob']['Transcript']['TranscriptFileUri']
        data = urlopen(uri).read()
        data = data.decode('utf-8')
        return data

    def get_job_status(self, job_name):
        response = self.scribe.get_transcription_job(
            TranscriptionJobName=job_name
        )
        # this will be 'QUEUED'|'IN_PROGRESS'|'FAILED'|'COMPLETED'
        job_status = response['TranscriptionJob']['TranscriptionJobStatus']
        return job_status

    def delete_job(self, job_name):
        self.scribe.delete_transcription_job(
            TranscriptionJobName=job_name
        )
        print('deleted job "{}"'.format(job_name))

    def poll_job(self, job_name):
        """ poll until a job returns COMPLETED

        raise an exception if it fails
        """

        while True:
            status = self.get_job_status(job_name)
            if status in ('QUEUED', 'IN_PROGRESS'):
                print('transcribe job "{}" is {}, please wait...'.format(job_name, status))
                time.sleep(15)
                continue
            if status == 'COMPLETED':
                print('finished!')
                return
            raise TranscribeError('job error', status)

    def start_job(self, job_name, audio_uri, vocab_name):

        settings = {
            'ShowSpeakerLabels': False,
            'ChannelIdentification': False,
            'ShowAlternatives': False,
        }
        if vocab_name:
            settings['VocabularyName'] = vocab_name

        response = self.scribe.start_transcription_job(
            TranscriptionJobName=job_name,
            LanguageCode='en-US',
            Media={
                'MediaFileUri': audio_uri
            },
            Settings=settings,
        )
        assert response['ResponseMetadata']['HTTPStatusCode'] == 200

    def get_job_results(self, job_name):
        self.poll_job(job_name)
        json_txt = self.fetch_transcript(job_name)
        output_filename = '{}.txt'.format(job_name)
        dump_transcript_json(json_txt, output_filename)

def create_vocabulary_id():
    """ create a string that uniquely identifies one version of the vocabulary file
    """
    vocab = open('aws_vocabulary.txt', 'rb').read()
    hex_id = hashlib.sha256(vocab).hexdigest()[:12]
    return 'Rustacean-{}'.format(hex_id)


def dump_transcript_json(json_txt, output_filename):
    """
    The JSON format is (roughly):
    {
        'accountId': a big ID number
        'jobName': a string, what you named the job
        'status': hopefully, 'COMPLETED'
        'speaker_labels': if you enabled speaker identification, a list of timestamps
        'results': {
            'items': a list of dictionaries containing metadata of the form
            {
                'start_time': the starting timestamp for this word
                'end_time': the ending timestamp for this word
                'type': one of ('pronunciation', 'punctuation')
                'alternatives': a list of alternative words
            }
            'transcripts': a list of transcript dictionaries of the form
            {
                'transcript': giant string containing the actual transcription
            }
        }
    }
    Sadly, the JSON data does not link the timestamps to the offset
    in the transcript text, so it's pretty useless by itself.
    """
    data = json.loads(json_txt)

    print('writing transcript to "{}"'.format(output_filename))

    with open(output_filename, 'w') as f:
        for transcript in data['results']['transcripts']:
            f.write(transcript['transcript'])


if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    parser.add_argument('--start-job', action='store_true')
    parser.add_argument('--delete-job', action='store_true')
    parser.add_argument('--download-results', action='store_true')
    parser.add_argument('--audio-uri')
    parser.add_argument('--job-name')
    parser.add_argument('--vocab-name')
    parser.add_argument('--json-file', metavar='JSON-FILE', help='filename of a json transcription result')
    parser.add_argument('--list-vocab', action='store_true')
    args = parser.parse_args()

    transcriber = AwsTranscribe()
    if args.list_vocab:
        transcriber.list_vocab()
    if args.delete_job:
        transcriber.delete_job(args.job_name)
    if args.start_job:
        transcriber.start_job(args.job_name, args.audio_uri, args.vocab_name)
    if args.download_results:
        if not args.job_name:
            print('--job-name is required', file=sys.stdout)
            sys.exit(1)
        transcriber.get_job_results(args.job_name)
